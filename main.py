import os
import json
import aiohttp
import asyncio
from datetime import datetime, timezone
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardRemove
from aiogram.filters import Command
from aiogram.utils.markdown import hcode
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
BOT_TOKEN = os.getenv("BOT_TOKEN", "–í–ê–®_–ë–û–¢_–¢–û–ö–ï–ù_–¢–£–¢") 
if BOT_TOKEN == "–í–ê–®_–ë–û–¢_–¢–û–ö–ï–ù_–¢–£–¢":
    print("–ü–û–ü–ï–†–ï–î–ñ–ï–ù–ù–Ø: –ë—É–¥—å –ª–∞—Å–∫–∞, –≤—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å –≤–∞—à —Å–ø—Ä–∞–≤–∂–Ω—ñ–π BOT_TOKEN!")
    # exit() # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ, –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

DATA_FILE = "user_crypto_preferences.json" 

POPULAR_TOKENS_MAP = {
    'BTC': 'bitcoin', 'ETH': 'ethereum', 'SOL': 'solana', 
    'TON': 'the-open-network', 'DOGE': 'dogecoin', 'LINK': 'chainlink', 
    'ADA': 'cardano', 'DOT': 'polkadot', 'MATIC': 'matic-network', 'ARB': 'arbitrum'
}
POPULAR_TOKENS_ORDER = ['BTC', 'ETH', 'SOL', 'TON', 'DOGE', 'LINK', 'ADA', 'DOT', 'MATIC', 'ARB']

ADMIN_IDS = [696165311, 7923967086] 

# --- –°–û–°–¢–û–Ø–ù–ò–Ø FSM –î–õ–Ø –¶–ï–ù–û–í–´–• –ê–õ–ï–†–¢–û–í ---
class PriceAlertStates(StatesGroup):
    waiting_coin_ticker = State()
    waiting_lower_target = State()
    waiting_upper_target = State()

# --- –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –î–ê–ù–ù–´–ú–ò ---
def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding='utf-8') as f:
                content = f.read()
                if not content: 
                    return {}
                return json.loads(content)
        except json.JSONDecodeError:
            print(f"–ü–æ–º–∏–ª–∫–∞ –¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è JSON –∑ —Ñ–∞–π–ª—É {DATA_FILE}.")
            return {}
        except Exception as e:
            print(f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ: {e}")
            return {}
    return {}

def save_data(data):
    try:
        with open(DATA_FILE, "w", encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –¥–∞–Ω—ñ: {e}")

def get_default_user_config():
    return {
        "tokens_id": [],            
        "tokens_display": [],       
        "frequency": None,          
        "notification_times_utc": [],
        "price_alert_config": None 
    }

# --- –§–£–ù–ö–¶–ò–ò –î–õ–Ø API COINGECKO (–° –£–õ–£–ß–®–ï–ù–ù–´–ú –õ–û–ì–ò–†–û–í–ê–ù–ò–ï–ú) ---
async def fetch_price(symbol_id: str) -> str | float: # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–Ω—É –∏–ª–∏ —Å—Ç—Ä–æ–∫—É –æ—à–∏–±–∫–∏
    url = f"https://api.coingecko.com/api/v3/simple/price?ids={symbol_id}&vs_currencies=usd"
    log_prefix = f"[{datetime.now(timezone.utc).isoformat()}] FetchPrice ({symbol_id}):"
    try:
        async with aiohttp.ClientSession() as session:
            headers = {'User-Agent': 'Mozilla/5.0 (TelegramBot/1.0)'} # –ü—Ä–æ—Å—Ç–æ–π User-Agent
            async with session.get(url, timeout=15, headers=headers) as resp:
                response_text = await resp.text()
                if resp.status == 200:
                    data = json.loads(response_text)
                    price_data = data.get(symbol_id, {})
                    price = price_data.get("usd")
                    if price is not None:
                        return float(price) 
                    else:
                        print(f"{log_prefix} 'usd' price not found in response: {data}")
                        return "NoPriceData"
                else:
                    print(f"{log_prefix} API Error. Status: {resp.status}, Response: {response_text}")
                    return "ErrorAPI" 
    except asyncio.TimeoutError:
        print(f"{log_prefix} API Timeout.")
        return "Timeout"
    except aiohttp.ClientConnectorError as e:
        print(f"{log_prefix} API Connection Error: {e}")
        return "ConnectionError"
    except Exception as e:
        print(f"{log_prefix} API General Error: {e}")
        return "Error"
    return "N/A"

async def fetch_prices_batch(symbol_ids: list[str]) -> dict:
    if not symbol_ids:
        return {}
    
    ids_query_param = ",".join(symbol_ids)
    url = f"https://api.coingecko.com/api/v3/simple/price?ids={ids_query_param}&vs_currencies=usd"
    results = {sym_id: "N/A" for sym_id in symbol_ids}
    log_prefix = f"[{datetime.now(timezone.utc).isoformat()}] FetchPricesBatch ({ids_query_param}):"

    try:
        async with aiohttp.ClientSession() as session:
            headers = {'User-Agent': 'Mozilla/5.0 (TelegramBot/1.0)'}
            async with session.get(url, timeout=15, headers=headers) as resp:
                response_text = await resp.text()
                if resp.status == 200:
                    data = json.loads(response_text)
                    for symbol_id in symbol_ids:
                        price_data = data.get(symbol_id, {})
                        price = price_data.get("usd")
                        if price is not None:
                            results[symbol_id] = float(price)
                        else:
                            results[symbol_id] = "NoPriceData"
                            print(f"{log_prefix} 'usd' price not found for {symbol_id} in batch response: {data}")
                    return results
                else:
                    print(f"{log_prefix} API Error. Status: {resp.status}, Response: {response_text}")
                    for symbol_id in symbol_ids: results[symbol_id] = "ErrorAPI"
                    return results
    except asyncio.TimeoutError:
        print(f"{log_prefix} API Timeout.")
        for symbol_id in symbol_ids: results[symbol_id] = "Timeout"
    except aiohttp.ClientConnectorError as e:
        print(f"{log_prefix} API Connection Error: {e}")
        for symbol_id in symbol_ids: results[symbol_id] = "ConnectionError"
    except Exception as e:
        print(f"{log_prefix} API General Error: {e}")
        for symbol_id in symbol_ids: results[symbol_id] = "Error"
    return results

async def search_token(query: str): # –û—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –±—ã–ª–æ, –Ω–æ —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ –±–∞–∑–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
    url = f"https://api.coingecko.com/api/v3/search?query={query}"
    log_prefix = f"[{datetime.now(timezone.utc).isoformat()}] SearchToken ({query}):"
    try:
        async with aiohttp.ClientSession() as session:
            headers = {'User-Agent': 'Mozilla/5.0 (TelegramBot/1.0)'}
            async with session.get(url, timeout=10, headers=headers) as resp:
                if resp.status == 200:
                    result = await resp.json()
                    coins = result.get("coins", [])
                    if coins:
                        coin = coins[0]
                        return coin.get("id"), coin.get("name"), coin.get("symbol")
                else:
                    print(f"{log_prefix} API Error. Status: {resp.status}, Response: {await resp.text()}")
    except asyncio.TimeoutError:
        print(f"{log_prefix} API Timeout.")
    except Exception as e:
        print(f"{log_prefix} API General Error: {e}")
    return None, None, None

# --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
def get_frequency_description_text(freq_code: str | None, notification_times_utc: list | None = None) -> str:
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º –æ—Ç–≤–µ—Ç–µ) ...
    if not freq_code:
        return "–Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ (—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω—ñ)"
    if freq_code == "hourly":
        return "–©–æ–≥–æ–¥–∏–Ω–∏"
    elif freq_code == "2_hours":
        return "–ö–æ–∂–Ω—ñ 2 –≥–æ–¥–∏–Ω–∏"
    elif freq_code == "daily_1":
        time_str = notification_times_utc[0] if notification_times_utc and notification_times_utc[0] else "09:00"
        return f"1 —Ä–∞–∑ –Ω–∞ –¥–µ–Ω—å (–æ {time_str} UTC)"
    elif freq_code == "daily_2":
        t1 = notification_times_utc[0] if notification_times_utc and len(notification_times_utc) > 0 else "09:00"
        t2 = notification_times_utc[1] if notification_times_utc and len(notification_times_utc) > 1 else "21:00"
        return f"2 —Ä–∞–∑–∏ –Ω–∞ –¥–µ–Ω—å (–æ {t1} —Ç–∞ {t2} UTC)"
    return "–ù–µ–≤—ñ–¥–æ–º–∞ —á–∞—Å—Ç–æ—Ç–∞"

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î –ò CALLBACK (–í–∫–ª—é—á–∞—è FSM –¥–ª—è Price Alerts) ---
# /start
@dp.message(Command("start"))
async def start_cmd(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º –æ—Ç–≤–µ—Ç–µ) ...
    user_id = str(message.chat.id)
    data = load_data()
    if user_id not in data:
        data[user_id] = get_default_user_config()
        save_data(data)

    kb_buttons = []
    for i in range(0, len(POPULAR_TOKENS_ORDER), 2):
        row = []
        display_ticker1 = POPULAR_TOKENS_ORDER[i]
        coin_id1 = POPULAR_TOKENS_MAP[display_ticker1]
        row.append(InlineKeyboardButton(text=display_ticker1, callback_data=f"add_{coin_id1}_{display_ticker1}"))
        
        if i + 1 < len(POPULAR_TOKENS_ORDER):
            display_ticker2 = POPULAR_TOKENS_ORDER[i+1]
            coin_id2 = POPULAR_TOKENS_MAP[display_ticker2]
            row.append(InlineKeyboardButton(text=display_ticker2, callback_data=f"add_{coin_id2}_{display_ticker2}"))
        kb_buttons.append(row)
    
    kb = InlineKeyboardMarkup(inline_keyboard=kb_buttons)

    await message.answer(
        "–ü—Ä–∏–≤—ñ—Ç! –Ø –¥–æ–ø–æ–º–æ–∂—É —Ç–æ–±—ñ –≤—ñ–¥—Å–ª—ñ–¥–∫–æ–≤—É–≤–∞—Ç–∏ —Ü—ñ–Ω–∏ –Ω–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∏.\n\n"
        "üì• <b>–û–±–µ—Ä–∏ –¥–æ 5 –º–æ–Ω–µ—Ç –∑—ñ —Å–ø–∏—Å–∫—É –ø–æ–ø—É–ª—è—Ä–Ω–∏—Ö:</b>", 
        reply_markup=kb, parse_mode="HTML"
    )
    await message.answer(
        "üîç <b>–ê–±–æ –Ω–∞–ø–∏—à–∏ —Å–∫–æ—Ä–æ—á–µ–Ω–Ω—è (—Ç—ñ–∫–µ—Ä) –º–æ–Ω–µ—Ç–∏</b> (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: `arb` –∞–±–æ `Bitcoin`), —â–æ–± –∑–Ω–∞–π—Ç–∏ —ó—ó —á–µ—Ä–µ–∑ –ø–æ—à—É–∫.\n\n"
        "–ü—ñ—Å–ª—è –≤–∏–±–æ—Ä—É –º–æ–Ω–µ—Ç, –Ω–∞–ª–∞—à—Ç—É–π —á–∞—Å—Ç–æ—Ç—É —Å–ø–æ–≤—ñ—â–µ–Ω—å –∫–æ–º–∞–Ω–¥–æ—é /setfrequency.\n"
        "–¢–∞–∫–æ–∂ –º–æ–∂–µ—à –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ <b>—Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è</b> –Ω–∞ –æ–¥–Ω—É –º–æ–Ω–µ—Ç—É: /setpricealert\n\n" # –î–æ–±–∞–≤–ª–µ–Ω–æ –ø—Ä–æ price alert
        "<b>–Ü–Ω—à—ñ –∫–æ–º–∞–Ω–¥–∏:</b>\n"
        "/mycryptoconfig - –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –ø–æ—Ç–æ—á–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å\n"
        "/mypricealert - –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ü—ñ–Ω–æ–≤–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è\n" # –î–æ–±–∞–≤–ª–µ–Ω–æ
        "/resetcrypto - —Å–∫–∏–Ω—É—Ç–∏ –≤—Å—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–≤–∫–ª—é—á–∞—é—á–∏ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è)\n"
        "/stopcryptonotifications - –∑—É–ø–∏–Ω–∏—Ç–∏ —Ä–µ–≥—É–ª—è—Ä–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —Ü—ñ–Ω–∏\n"
        "/removepricealert - –≤–∏–º–∫–Ω—É—Ç–∏ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è", # –î–æ–±–∞–≤–ª–µ–Ω–æ
        parse_mode="HTML"
    )

# /mycryptoconfig
@dp.message(Command("mycryptoconfig"))
async def my_config_cmd(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    user_id = str(message.chat.id)
    data = load_data()
    user_config = data.get(user_id)

    if not user_config:
        await message.answer("–£ –≤–∞—Å —â–µ –Ω–µ–º–∞—î –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å. –ü–æ—á–Ω—ñ—Ç—å –∑ –∫–æ–º–∞–Ω–¥–∏ /start.")
        return

    tokens_display_str = ", ".join(user_config.get("tokens_display", []))
    if not tokens_display_str:
        tokens_display_str = "–Ω–µ –æ–±—Ä–∞–Ω–æ"
    
    frequency_code = user_config.get("frequency")
    notification_times = user_config.get("notification_times_utc")
    freq_desc = get_frequency_description_text(frequency_code, notification_times)

    await message.answer(
        f"<b>‚öôÔ∏è –í–∞—à—ñ –ø–æ—Ç–æ—á–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å:</b>\n\n"
        f"<b>–û–±—Ä–∞–Ω—ñ –º–æ–Ω–µ—Ç–∏:</b> {tokens_display_str}\n"
        f"<b>–ß–∞—Å—Ç–æ—Ç–∞ —Å–ø–æ–≤—ñ—â–µ–Ω—å:</b> {freq_desc}\n\n"
        "–©–æ–± –∑–º—ñ–Ω–∏—Ç–∏ –º–æ–Ω–µ—Ç–∏, –ø—Ä–æ—Å—Ç–æ –¥–æ–¥–∞–π—Ç–µ –Ω–æ–≤—ñ –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /resetcrypto.\n"
        "–©–æ–± –∑–º—ñ–Ω–∏—Ç–∏ —á–∞—Å—Ç–æ—Ç—É, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /setfrequency.",
        parse_mode="HTML"
    )

# Callback add_
@dp.callback_query(lambda c: c.data.startswith("add_"))
async def add_token_callback(callback_query: types.CallbackQuery):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    user_id = str(callback_query.from_user.id)
    try:
        _, coin_id, display_ticker = callback_query.data.split("_", 2)
    except ValueError:
        await callback_query.answer("–ü–æ–º–∏–ª–∫–∞ –¥–∞–Ω–∏—Ö –∫–Ω–æ–ø–∫–∏.", show_alert=True)
        print(f"–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç callback_data: {callback_query.data}")
        return

    data = load_data()
    user_config = data.get(user_id, get_default_user_config()) 

    tokens_id_list = user_config.get("tokens_id", [])
    tokens_display_list = user_config.get("tokens_display", [])

    if coin_id in tokens_id_list:
        await callback_query.answer(f"{display_ticker} –≤–∂–µ –æ–±—Ä–∞–Ω–æ", show_alert=False)
        return

    if len(tokens_id_list) >= 5:
        await callback_query.answer("–í–∂–µ –æ–±—Ä–∞–Ω–æ 5 –º–æ–Ω–µ—Ç. –ú–∞–∫—Å–∏–º—É–º.", show_alert=True)
        return

    tokens_id_list.append(coin_id)
    tokens_display_list.append(display_ticker)
    
    user_config["tokens_id"] = tokens_id_list
    user_config["tokens_display"] = tokens_display_list
    data[user_id] = user_config
    save_data(data)

    await callback_query.answer(f"–î–æ–¥–∞–Ω–æ {display_ticker}", show_alert=False)
    await bot.send_message(user_id, f"‚úÖ –î–æ–¥–∞–Ω–æ: {display_ticker} (ID: {hcode(coin_id)})", parse_mode="HTML")

    if len(tokens_id_list) >= 5: 
        await bot.send_message(user_id, "–í–∏ –æ–±—Ä–∞–ª–∏ 5 –º–æ–Ω–µ—Ç. –¢–µ–ø–µ—Ä –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ —á–∞—Å—Ç–æ—Ç—É —Å–ø–æ–≤—ñ—â–µ–Ω—å: /setfrequency")
    elif len(tokens_id_list) > 0: 
        await bot.send_message(user_id, "–©–æ–± –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ —á–∞—Å—Ç–æ—Ç—É —Å–ø–æ–≤—ñ—â–µ–Ω—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /setfrequency")

# /setfrequency
@dp.message(Command("setfrequency"))
async def set_frequency_cmd(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    user_id = str(message.chat.id)
    data = load_data()
    user_config = data.get(user_id)

    if not user_config or not user_config.get("tokens_id"):
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –æ–±–µ—Ä—ñ—Ç—å —Ö–æ—á–∞ –± –æ–¥–Ω—É –º–æ–Ω–µ—Ç—É.\n"
                             "–í–∏ –º–æ–∂–µ—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ —Ü–µ —á–µ—Ä–µ–∑ /start –∞–±–æ –Ω–∞–ø–∏—Å–∞–≤—à–∏ —Ç—ñ–∫–µ—Ä –º–æ–Ω–µ—Ç–∏ –≤ —á–∞—Ç.")
        return

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–©–æ–≥–æ–¥–∏–Ω–∏", callback_data="setfreq_hourly")],
        [InlineKeyboardButton(text="–ö–æ–∂–Ω—ñ 2 –≥–æ–¥–∏–Ω–∏", callback_data="setfreq_2_hours")],
        [InlineKeyboardButton(text="1 —Ä–∞–∑ –Ω–∞ –¥–µ–Ω—å (09:00 UTC)", callback_data="setfreq_daily_1_09:00")],
        [InlineKeyboardButton(text="2 —Ä–∞–∑–∏ –Ω–∞ –¥–µ–Ω—å (09:00, 21:00 UTC)", callback_data="setfreq_daily_2_09:00_21:00")],
        [InlineKeyboardButton(text="üö´ –í–∏–º–∫–Ω—É—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è", callback_data="setfreq_off")]
    ])
    await message.answer("‚è∞ –û–±–µ—Ä—ñ—Ç—å —á–∞—Å—Ç–æ—Ç—É —Å–ø–æ–≤—ñ—â–µ–Ω—å (—á–∞—Å –≤–∫–∞–∑–∞–Ω–æ –≤ UTC):", reply_markup=kb)

# Callback setfreq_
@dp.callback_query(lambda c: c.data.startswith("setfreq_"))
async def process_frequency_callback(callback_query: types.CallbackQuery):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    user_id = str(callback_query.from_user.id)
    action_parts = callback_query.data.split("_") 
    
    frequency_selection = action_parts[1] 
    
    data = load_data()
    user_config = data.get(user_id, get_default_user_config())

    new_frequency = None
    new_times_utc = []

    if frequency_selection == "off":
        new_frequency = None
    elif frequency_selection == "hourly":
        new_frequency = "hourly"
    elif frequency_selection == "2": 
        new_frequency = "2_hours"
    elif frequency_selection == "daily":
        if action_parts[2] == "1": 
            new_frequency = "daily_1"
            new_times_utc = [action_parts[3]] 
        elif action_parts[2] == "2": 
            new_frequency = "daily_2"
            new_times_utc = [action_parts[3], action_parts[4]] 
    
    user_config["frequency"] = new_frequency
    user_config["notification_times_utc"] = new_times_utc
    data[user_id] = user_config
    save_data(data)
    
    final_freq_desc = get_frequency_description_text(new_frequency, new_times_utc)
    await callback_query.message.edit_text(f"‚úÖ –ß–∞—Å—Ç–æ—Ç—É —Å–ø–æ–≤—ñ—â–µ–Ω—å –æ–Ω–æ–≤–ª–µ–Ω–æ: <b>{final_freq_desc}</b>", parse_mode="HTML")
    if new_frequency: 
      await callback_query.answer(f"–ß–∞—Å—Ç–æ—Ç—É –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {final_freq_desc}", show_alert=False)
    else:
      await callback_query.answer("–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ.", show_alert=False)

# --- FSM –¥–ª—è /setpricealert ---
@dp.message(Command("setpricealert"))
async def cmd_set_price_alert_start(message: types.Message, state: FSMContext):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    await state.set_state(PriceAlertStates.waiting_coin_ticker)
    await message.answer(
        "<b>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ü—ñ–Ω–æ–≤–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è.</b>\n"
        "–ù–∞–ø–∏—à—ñ—Ç—å —Ç—ñ–∫–µ—Ä –º–æ–Ω–µ—Ç–∏, –¥–ª—è —è–∫–æ—ó –≤–∏ —Ö–æ—á–µ—Ç–µ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, BTC, ETH, SOL):",
        parse_mode="HTML"
    )

@dp.message(PriceAlertStates.waiting_coin_ticker)
async def process_alert_coin_ticker(message: types.Message, state: FSMContext):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    ticker_input = message.text.strip().lower()
    if not ticker_input or len(ticker_input) > 15:
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–∏–π —Ç—ñ–∫–µ—Ä (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, BTC). –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å /cancelalert.")
        return

    coin_id, coin_name, coin_symbol_api = await search_token(ticker_input)

    if not coin_id:
        await message.answer(f"‚ùå –ú–æ–Ω–µ—Ç—É '{message.text.strip()}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–∏–π —Ç—ñ–∫–µ—Ä –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å /cancelalert.")
        return

    display_name = coin_symbol_api.upper() if coin_symbol_api else coin_name

    await state.update_data(alert_coin_id=coin_id, alert_coin_display=display_name)
    await state.set_state(PriceAlertStates.waiting_lower_target)
    await message.answer(
        f"–û–±—Ä–∞–Ω–æ –º–æ–Ω–µ—Ç—É: <b>{display_name}</b> (ID: {hcode(coin_id)}).\n"
        "–¢–µ–ø–µ—Ä –≤–≤–µ–¥—ñ—Ç—å <b>–Ω–∏–∂–Ω—ñ–π</b> –ø–æ—Ä—ñ–≥ —Ü—ñ–Ω–∏ (–≤ USD), –ø—Ä–∏ –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—ñ —è–∫–æ–≥–æ –≤–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 29500.50):",
        parse_mode="HTML"
    )

@dp.message(PriceAlertStates.waiting_lower_target)
async def process_alert_lower_target(message: types.Message, state: FSMContext):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    try:
        lower_target = float(message.text.strip().replace(',', '.')) 
        if lower_target <= 0:
            raise ValueError("–¶—ñ–Ω–∞ –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –ø–æ–∑–∏—Ç–∏–≤–Ω–æ—é.")
    except ValueError:
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –Ω–∏–∂–Ω—å–æ–≥–æ –ø–æ—Ä–æ–≥—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 29500.50) –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å /cancelalert.")
        return

    await state.update_data(lower_target=lower_target)
    await state.set_state(PriceAlertStates.waiting_upper_target)
    await message.answer(
        f"–ù–∏–∂–Ω—ñ–π –ø–æ—Ä—ñ–≥ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: <b>${lower_target:,.2f}</b>.\n"
        "–¢–µ–ø–µ—Ä –≤–≤–µ–¥—ñ—Ç—å <b>–≤–µ—Ä—Ö–Ω—ñ–π</b> –ø–æ—Ä—ñ–≥ —Ü—ñ–Ω–∏ (–≤ USD), –≤—ñ–Ω –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–∏–º –∑–∞ –Ω–∏–∂–Ω—ñ–π (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 31000):",
        parse_mode="HTML"
    )

@dp.message(PriceAlertStates.waiting_upper_target)
async def process_alert_upper_target(message: types.Message, state: FSMContext):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    try:
        upper_target = float(message.text.strip().replace(',', '.'))
        user_fsm_data = await state.get_data()
        lower_target = user_fsm_data.get('lower_target')

        if upper_target <= 0:
             raise ValueError("–¶—ñ–Ω–∞ –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –ø–æ–∑–∏—Ç–∏–≤–Ω–æ—é.")
        if lower_target is not None and upper_target <= lower_target:
            await message.answer(f"–í–µ—Ä—Ö–Ω—ñ–π –ø–æ—Ä—ñ–≥ (<b>${upper_target:,.2f}</b>) –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–∏–º –∑–∞ –Ω–∏–∂–Ω—ñ–π (<b>${lower_target:,.2f}</b>). "
                                 "–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å /cancelalert.", parse_mode="HTML")
            return
    except ValueError:
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –≤–µ—Ä—Ö–Ω—å–æ–≥–æ –ø–æ—Ä–æ–≥—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 31000) –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å /cancelalert.")
        return

    user_id = str(message.from_user.id)
    all_data = load_data()
    user_config = all_data.get(user_id, get_default_user_config())

    user_config["price_alert_config"] = {
        "coin_id": user_fsm_data.get('alert_coin_id'),
        "coin_display": user_fsm_data.get('alert_coin_display'),
        "lower_target": lower_target,
        "upper_target": upper_target,
        "alert_sent_lower": False, 
        "alert_sent_upper": False,
        "is_active": True
    }
    all_data[user_id] = user_config
    save_data(all_data)

    await state.clear() 
    await message.answer(
        f"‚úÖ <b>–¶—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ!</b>\n"
        f"–ú–æ–Ω–µ—Ç–∞: <b>{user_config['price_alert_config']['coin_display']}</b>\n"
        f"–ù–∏–∂–Ω—ñ–π –ø–æ—Ä—ñ–≥: <b>${user_config['price_alert_config']['lower_target']:,.2f}</b>\n"
        f"–í–µ—Ä—Ö–Ω—ñ–π –ø–æ—Ä—ñ–≥: <b>${user_config['price_alert_config']['upper_target']:,.2f}</b>\n\n"
        "–í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∫–æ–ª–∏ —Ü—ñ–Ω–∞ –¥–æ—Å—è–≥–Ω–µ –æ–¥–Ω–æ–≥–æ –∑ —Ü–∏—Ö –ø–æ—Ä–æ–≥—ñ–≤.",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove() 
    )

@dp.message(Command("cancelalert"), PriceAlertStates.any_state)
async def cancel_alert_setup(message: types.Message, state: FSMContext):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    current_state = await state.get_state()
    if current_state is None:
        await message.answer("–ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–æ—ó —Å–µ—Å—ñ—ó –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è.")
        return

    await state.clear()
    await message.answer("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ü—ñ–Ω–æ–≤–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.", reply_markup=ReplyKeyboardRemove())

# /mypricealert
@dp.message(Command("mypricealert"))
async def cmd_my_price_alert(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    user_id = str(message.chat.id)
    data = load_data()
    user_config = data.get(user_id)
    alert_config = user_config.get("price_alert_config") if user_config else None

    if alert_config and alert_config.get("is_active"):
        await message.answer(
            f"<b>üîî –í–∞—à–µ –ø–æ—Ç–æ—á–Ω–µ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è:</b>\n"
            f"–ú–æ–Ω–µ—Ç–∞: <b>{alert_config['coin_display']}</b> (ID: {hcode(alert_config['coin_id'])})\n"
            f"–ù–∏–∂–Ω—ñ–π –ø–æ—Ä—ñ–≥: <b>${alert_config['lower_target']:,.2f}</b>\n"
            f"–í–µ—Ä—Ö–Ω—ñ–π –ø–æ—Ä—ñ–≥: <b>${alert_config['upper_target']:,.2f}</b>\n\n"
            "–©–æ–± –∑–º—ñ–Ω–∏—Ç–∏, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /setpricealert.\n"
            "–©–æ–± –≤–∏–º–∫–Ω—É—Ç–∏, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /removepricealert.",
            parse_mode="HTML"
        )
    else:
        await message.answer("–£ –≤–∞—Å –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ü—ñ–Ω–æ–≤–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å. –ù–∞–ª–∞—à—Ç—É–π—Ç–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é /setpricealert.")

# /removepricealert
@dp.message(Command("removepricealert"))
async def cmd_remove_price_alert(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞) ...
    user_id = str(message.chat.id)
    data = load_data()
    user_config = data.get(user_id)

    if user_config and user_config.get("price_alert_config") and user_config["price_alert_config"].get("is_active"):
        user_config["price_alert_config"]["is_active"] = False 
        data[user_id] = user_config
        save_data(data)
        await message.answer("üóëÔ∏è –í–∞—à–µ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ. –í–∏ –±—ñ–ª—å—à–µ –Ω–µ –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏–º–µ—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –ø–æ –Ω—å–æ–º—É.\n"
                             "–©–æ–± –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –Ω–æ–≤–µ, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /setpricealert.")
    else:
        await message.answer("–£ –≤–∞—Å –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ü—ñ–Ω–æ–≤–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å –¥–ª—è –≤–∏–º–∫–Ω–µ–Ω–Ω—è.")

# /resetcrypto (—Ç–µ–ø–µ—Ä—å —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç –∏ price_alert_config)
@dp.message(Command("resetcrypto")) 
async def reset_crypto_all_cmd(message: types.Message):
    user_id = str(message.from_user.id)
    data = load_data()
    if user_id in data:
        data[user_id] = get_default_user_config() # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –≤–∫–ª—é—á–∞—è price_alert_config = None
        save_data(data)
        await message.answer("‚ôªÔ∏è –í—Å—ñ –≤–∞—à—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–≤–∫–ª—é—á–∞—é—á–∏ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è) —Å–∫–∏–Ω—É—Ç–æ. /start —â–æ–± –ø–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É.")
    else:
        await message.answer("–£ –≤–∞—Å —â–µ –Ω–µ–º–∞—î –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å –¥–ª—è —Å–∫–∏–¥–∞–Ω–Ω—è.")

# Callback reset_all_crypto (—Ç–µ–ø–µ—Ä—å —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç –∏ price_alert_config)
@dp.callback_query(lambda c: c.data == "reset_all_crypto")
async def reset_crypto_all_callback(callback_query: types.CallbackQuery):
    user_id = str(callback_query.from_user.id)
    data = load_data()
    if user_id in data:
        data[user_id] = get_default_user_config()
        save_data(data)
    try:
        await callback_query.message.edit_text("‚ôªÔ∏è –í—Å—ñ –≤–∞—à—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–≤–∫–ª—é—á–∞—é—á–∏ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è) —Å–∫–∏–Ω—É—Ç–æ. /start —â–æ–± –ø–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É.")
    except Exception: 
        await bot.send_message(user_id, "‚ôªÔ∏è –í—Å—ñ –≤–∞—à—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–≤–∫–ª—é—á–∞—é—á–∏ —Ü—ñ–Ω–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è) —Å–∫–∏–Ω—É—Ç–æ. /start —â–æ–± –ø–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É.")
    await callback_query.answer("–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–∫–∏–Ω—É—Ç–æ", show_alert=False)

# /stopcryptonotifications
@dp.message(Command("stopcryptonotifications"))
async def stop_crypto_notifications_cmd(message: types.Message):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è) ...
    user_id = str(message.from_user.id)
    data = load_data()
    user_config = data.get(user_id)

    if user_config and user_config.get("frequency") is not None:
        user_config["frequency"] = None
        user_config["notification_times_utc"] = [] 
        data[user_id] = user_config
        save_data(data)
        await message.answer("‚ùå –†–µ–≥—É–ª—è—Ä–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∏ –∑—É–ø–∏–Ω–µ–Ω—ñ.")
    else:
        await message.answer("–†–µ–≥—É–ª—è—Ä–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–∂–µ –≤–∏–º–∫–Ω–µ–Ω—ñ –∞–±–æ –Ω–µ –±—É–ª–∏ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω—ñ.")


# --- –ü–õ–ê–ù–ò–†–û–í–©–ò–ö (–û–ë–™–ï–î–ò–ù–ï–ù–ù–´–ô) ---
async def check_and_process_price_alerts(user_id_int: int, user_config: dict):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –æ—Ç–≤–µ—Ç–∞, —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Ü–µ–Ω—ã) ...
    alert_config = user_config.get("price_alert_config")
    if not alert_config or not alert_config.get("is_active"):
        return 

    coin_id_to_check = alert_config.get("coin_id")
    if not coin_id_to_check:
        return

    current_price_result = await fetch_price(coin_id_to_check) # –≠—Ç–æ —É–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç float –∏–ª–∏ —Å—Ç—Ä–æ–∫—É –æ—à–∏–±–∫–∏
    
    if not isinstance(current_price_result, (int, float)):
        # print(f"[{datetime.now(timezone.utc).isoformat()}] –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —á–∏—Å–ª–æ–≤—É —Ü—ñ–Ω—É –¥–ª—è {coin_id_to_check} –¥–ª—è –∞–ª–µ—Ä—Ç—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id_int}. –û—Ç—Ä–∏–º–∞–Ω–æ: {current_price_result}")
        return 

    current_price = current_price_result # –¢–µ–ø–µ—Ä—å —ç—Ç–æ —Ç–æ—á–Ω–æ float

    lower_target = alert_config.get("lower_target")
    upper_target = alert_config.get("upper_target")
    alert_sent_lower = alert_config.get("alert_sent_lower", False)
    alert_sent_upper = alert_config.get("alert_sent_upper", False)
    coin_display = alert_config.get("coin_display", coin_id_to_check.capitalize())

    data_changed = False 

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∏–∂–Ω–µ–≥–æ –ø–æ—Ä–æ–≥–∞
    if lower_target is not None: # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø–æ—Ä–æ–≥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
        if not alert_sent_lower and current_price <= lower_target:
            message_text = (f"‚ö†Ô∏è <b>–¶—ñ–Ω–æ–≤–∏–π ALERT!</b> ‚ö†Ô∏è\n"
                            f"–ú–æ–Ω–µ—Ç–∞: <b>{coin_display}</b>\n"
                            f"–¶—ñ–Ω–∞ –¥–æ—Å—è–≥–ª–∞ –∞–±–æ –æ–ø—É—Å—Ç–∏–ª–∞—Å—è –Ω–∏–∂—á–µ –≤–∞—à–æ–≥–æ –ø–æ—Ä–æ–≥—É: <b>${lower_target:,.2f}</b>\n"
                            f"–ü–æ—Ç–æ—á–Ω–∞ —Ü—ñ–Ω–∞: <b>${current_price:,.2f}</b>")
            try:
                await bot.send_message(user_id_int, message_text, parse_mode="HTML")
                alert_config["alert_sent_lower"] = True
                data_changed = True
                print(f"[{datetime.now(timezone.utc).isoformat()}] –í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ ALERT (–Ω–∏–∂–Ω—ñ–π) –¥–ª—è {user_id_int} –ø–æ –º–æ–Ω–µ—Ç—ñ {coin_display}")
            except Exception as e:
                print(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ ALERT (–Ω–∏–∂–Ω—ñ–π) –¥–ª—è {user_id_int}: {e}")
        
        elif alert_sent_lower and current_price > lower_target * 1.002: 
            alert_config["alert_sent_lower"] = False
            data_changed = True
            print(f"[{datetime.now(timezone.utc).isoformat()}] '–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∂–µ–Ω–æ' –Ω–∏–∂–Ω—ñ–π ALERT –¥–ª—è {user_id_int} –ø–æ –º–æ–Ω–µ—Ç—ñ {coin_display} (—Ü—ñ–Ω–∞: ${current_price:,.2f})")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Ö–Ω–µ–≥–æ –ø–æ—Ä–æ–≥–∞
    if upper_target is not None: # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø–æ—Ä–æ–≥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
        if not alert_sent_upper and current_price >= upper_target:
            message_text = (f"‚ö†Ô∏è <b>–¶—ñ–Ω–æ–≤–∏–π ALERT!</b> ‚ö†Ô∏è\n"
                            f"–ú–æ–Ω–µ—Ç–∞: <b>{coin_display}</b>\n"
                            f"–¶—ñ–Ω–∞ –¥–æ—Å—è–≥–ª–∞ –∞–±–æ –ø–µ—Ä–µ–≤–∏—â–∏–ª–∞ –≤–∞—à –ø–æ—Ä—ñ–≥: <b>${upper_target:,.2f}</b>\n"
                            f"–ü–æ—Ç–æ—á–Ω–∞ —Ü—ñ–Ω–∞: <b>${current_price:,.2f}</b>")
            try:
                await bot.send_message(user_id_int, message_text, parse_mode="HTML")
                alert_config["alert_sent_upper"] = True
                data_changed = True
                print(f"[{datetime.now(timezone.utc).isoformat()}] –í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ ALERT (–≤–µ—Ä—Ö–Ω—ñ–π) –¥–ª—è {user_id_int} –ø–æ –º–æ–Ω–µ—Ç—ñ {coin_display}")
            except Exception as e:
                print(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ ALERT (–≤–µ—Ä—Ö–Ω—ñ–π) –¥–ª—è {user_id_int}: {e}")

        elif alert_sent_upper and current_price < upper_target * 0.998: 
            alert_config["alert_sent_upper"] = False
            data_changed = True
            print(f"[{datetime.now(timezone.utc).isoformat()}] '–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∂–µ–Ω–æ' –≤–µ—Ä—Ö–Ω—ñ–π ALERT –¥–ª—è {user_id_int} –ø–æ –º–æ–Ω–µ—Ç—ñ {coin_display} (—Ü—ñ–Ω–∞: ${current_price:,.2f})")

    if data_changed:
        all_users_data_local = load_data() 
        if str(user_id_int) in all_users_data_local: 
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ price_alert_config –≤–Ω—É—Ç—Ä–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ user_config
            if "price_alert_config" in all_users_data_local[str(user_id_int)]:
                 all_users_data_local[str(user_id_int)]["price_alert_config"].update(alert_config)
            else: # –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –µ–≥–æ —Ç–∞–º –Ω–µ –±—ã–ª–æ, –Ω–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ—Å–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                 all_users_data_local[str(user_id_int)]["price_alert_config"] = alert_config
            save_data(all_users_data_local)

async def send_user_price_update(user_id_int: int, user_config: dict, frequency: str):
    # ... (–∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º fetch_prices_batch, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –ª–æ–≥–∏–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—à–∏–±–æ–∫) ...
    tokens_id_list = user_config.get("tokens_id", [])
    if not tokens_id_list:
        return

    prices_info = []
    display_names = user_config.get("tokens_display", [])
    if not display_names or len(display_names) != len(tokens_id_list):
        display_names = [tid.capitalize() for tid in tokens_id_list] 

    fetched_prices_map = await fetch_prices_batch(tokens_id_list)
    # any_price_fetched = False # –ú–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å, –µ—Å–ª–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å/–Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å

    for i, token_cg_id in enumerate(tokens_id_list):
        price_result = fetched_prices_map.get(token_cg_id, "N/A") 
        token_display_name = display_names[i] if i < len(display_names) else token_cg_id.capitalize()
        
        if isinstance(price_result, (int, float)):
            prices_info.append(f"{token_display_name}: ${price_result:,.2f}")
            # any_price_fetched = True
        else: 
            error_display_text = "–Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö"
            if price_result == "ErrorAPI": error_display_text = "–ø–æ–º–∏–ª–∫–∞ API"
            elif price_result == "Timeout": error_display_text = "—Ç–∞–π–º–∞—É—Ç API"
            elif price_result == "ConnectionError": error_display_text = "–ø–æ–º–∏–ª–∫–∞ –∑ º—î–¥–Ω–∞–Ω–Ω—è"
            elif price_result == "NoPriceData": error_display_text = "—Ü—ñ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ"
            elif price_result == "N/A": error_display_text = "–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
            prices_info.append(f"{token_display_name}: {error_display_text}")
    
    if not prices_info:
        return

    freq_text_for_msg = get_frequency_description_text(frequency, user_config.get("notification_times_utc"))
    header = f"<b>üìà –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ü—ñ–Ω ({freq_text_for_msg.lower()})</b>"
    message_body = "\n".join(prices_info)
    final_message = f"{header}\n{message_body}"
    
    kb_after_price = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ôªÔ∏è –°–∫–∏–Ω—É—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è", callback_data="reset_all_crypto")],
        [InlineKeyboardButton(text="‚ùå –ó—É–ø–∏–Ω–∏—Ç–∏ —Ü—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è", callback_data="setfreq_off")]
    ])
    try:
        await bot.send_message(user_id_int, final_message, reply_markup=kb_after_price, parse_mode="HTML")
    except Exception as e:
        error_msg = str(e).lower()
        user_id_str = str(user_id_int) 
        if "bot was blocked" in error_msg or "user is deactivated" in error_msg or "chat not found" in error_msg:
            print(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {user_id_int} –∑–∞–±–ª–æ–∫—É–≤–∞–≤ –±–æ—Ç–∞ –∞–±–æ –Ω–µ —ñ—Å–Ω—É—î. –í–∏–¥–∞–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...")
            current_data_for_delete = load_data()
            if user_id_str in current_data_for_delete:
                del current_data_for_delete[user_id_str]
                save_data(current_data_for_delete)
        else:
            print(f"–ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É {user_id_int}: {e}")

async def price_update_scheduler():
    # ... (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Å –≤—ã–∑–æ–≤–æ–º send_user_price_update –∏ check_and_process_price_alerts)
    await asyncio.sleep(15) 
    print(f"[{datetime.now(timezone.utc).isoformat()}] –ü–ª–∞–Ω—É–≤–∞–ª—å–Ω–∏–∫ —Å–ø–æ–≤—ñ—â–µ–Ω—å (—Ä–µ–≥—É–ª—è—Ä–Ω—ñ + —Ü—ñ–Ω–æ–≤—ñ –∞–ª–µ—Ä—Ç–∏) –∑–∞–ø—É—â–µ–Ω–æ.")
    
    while True:
        now_utc = datetime.now(timezone.utc) 
        current_time_utc_str = now_utc.strftime("%H:%M")
        current_hour_utc = now_utc.hour
        
        all_users_data = load_data() 
        
        active_tasks = [] # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏ (—Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –∏ –∞–ª–µ—Ä—Ç—ã) –≤ –æ–¥–∏–Ω —Å–ø–∏—Å–æ–∫

        for user_id_str, user_config in all_users_data.items():
            try:
                user_id_int = int(user_id_str) 
            except ValueError:
                continue

            # --- –õ–æ–≥–∏–∫–∞ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π ---
            frequency = user_config.get("frequency")
            tokens_id_list = user_config.get("tokens_id")
            should_send_regular = False
            if frequency and tokens_id_list:
                if frequency == "hourly" and now_utc.minute == 0: should_send_regular = True
                elif frequency == "2_hours" and current_hour_utc % 2 == 0 and now_utc.minute == 0: should_send_regular = True
                elif frequency == "daily_1":
                    times_utc = user_config.get("notification_times_utc", [])
                    if times_utc and current_time_utc_str == times_utc[0]: should_send_regular = True
                elif frequency == "daily_2":
                    times_utc = user_config.get("notification_times_utc", [])
                    if times_utc and current_time_utc_str in times_utc: should_send_regular = True
            
            if should_send_regular:
                active_tasks.append(send_user_price_update(user_id_int, user_config.copy(), frequency)) # .copy() –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            
            # --- –õ–æ–≥–∏–∫–∞ –¥–ª—è —Ü–µ–Ω–æ–≤—ã—Ö –∞–ª–µ—Ä—Ç–æ–≤ ---
            if user_config.get("price_alert_config") and user_config["price_alert_config"].get("is_active"):
                active_tasks.append(check_and_process_price_alerts(user_id_int, user_config.copy())) # .copy()
        
        if active_tasks:
            print(f"[{datetime.now(timezone.utc).isoformat()}] –ó–Ω–∞–π–¥–µ–Ω–æ {len(active_tasks)} –∑–∞–≤–¥–∞–Ω—å –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è (—Ä–µ–≥—É–ª—è—Ä–Ω—ñ/–∞–ª–µ—Ä—Ç–∏).")
            # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –æ–¥–Ω–∞ —É–ø–∞–≤—à–∞—è –∑–∞–¥–∞—á–∞ –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∞ –≤—Å–µ
            results = await asyncio.gather(*active_tasks, return_exceptions=True)
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    print(f"[{datetime.now(timezone.utc).isoformat()}] –ü–æ–º–∏–ª–∫–∞ —É —Ñ–æ–Ω–æ–≤–æ–º—É –∑–∞–≤–¥–∞–Ω–Ω—ñ {active_tasks[i].__name__ if hasattr(active_tasks[i], '__name__') else 'task'}: {result}")

        await asyncio.sleep(60)

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô (–ê–î–ú–ò–ù / –ü–û–ò–°–ö –¢–û–ö–ï–ù–ê) ---
@dp.message() 
async def handle_text_input(message: types.Message, state: FSMContext): # –î–æ–±–∞–≤–∏–ª–∏ state
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞—Ö–æ–¥–∏–º—Å—è –ª–∏ –º—ã –≤ –∫–∞–∫–æ–º-–ª–∏–±–æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ FSM
    current_fsm_state = await state.get_state()
    if current_fsm_state is not None:
        # –ï—Å–ª–∏ –º—ã –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ FSM, —ç—Ç–æ—Ç —Ö–µ–Ω–¥–ª–µ—Ä –Ω–µ –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å –≤–≤–æ–¥,
        # –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –¥–ª—è FSM. –•–µ–Ω–¥–ª–µ—Ä—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–æ–ª–∂–Ω—ã —Å—Ä–∞–±–æ—Ç–∞—Ç—å —Ä–∞–Ω—å—à–µ.
        # –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏, –º–æ–∂–Ω–æ –≤—ã–≤–µ—Å—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å.
        # print(f"–°–æ–æ–±—â–µ–Ω–∏–µ '{message.text}' –ø–æ–ª—É—á–µ–Ω–æ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ FSM: {current_fsm_state}, –Ω–æ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ö–µ–Ω–¥–ª–µ—Ä–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è.")
        return 
        
    user_id_str = str(message.chat.id)
    text = message.text.strip()
    
    if message.from_user.id in ADMIN_IDS:
        if not text.startswith("/"): 
            all_users_data = load_data()
            sent_count = 0
            failed_count = 0
            
            active_subscribers = [uid_s for uid_s, info in all_users_data.items() if info.get("frequency") or (info.get("price_alert_config") and info["price_alert_config"].get("is_active"))] # –ê–¥–º–∏–Ω –ø–∏—à–µ—Ç –≤—Å–µ–º –∞–∫—Ç–∏–≤–Ω—ã–º

            if not active_subscribers:
                await message.answer("–ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –¥–ª—è —Ä–æ–∑—Å–∏–ª–∫–∏ (–∑ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ—é —á–∞—Å—Ç–æ—Ç–æ—é –∞–±–æ —Ü—ñ–Ω–æ–≤–∏–º –∞–ª–µ—Ä—Ç–æ–º).")
                return

            for uid_to_send_str in active_subscribers:
                try:
                    await bot.send_message(uid_to_send_str, text)
                    sent_count += 1
                except Exception as e:
                    failed_count += 1
                    print(f"–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—Å–∏–ª–∫–∏ –∞–¥–º—ñ–Ω–æ–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É {uid_to_send_str}: {e}")
            
            await message.answer(f"‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è —Ä–æ–∑—Å–∏–ª–∫–∏ –æ–±—Ä–æ–±–ª–µ–Ω–æ.\n"
                                 f"–ê–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –¥–ª—è —Ä–æ–∑—Å–∏–ª–∫–∏: {len(active_subscribers)}\n"
                                 f"–£—Å–ø—ñ—à–Ω–æ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ: {sent_count}\n"
                                 f"–ü–æ–º–∏–ª–æ–∫: {failed_count}")
            return 

    if text and not text.startswith("/"):
        all_users_data = load_data() 
        user_config = all_users_data.get(user_id_str, get_default_user_config())

        tokens_id_list = user_config.get("tokens_id", [])
        tokens_display_list = user_config.get("tokens_display", [])

        if len(tokens_id_list) >= 5:
            await message.answer("‚ùó –¢–∏ –≤–∂–µ –æ–±—Ä–∞–≤ 5 –º–æ–Ω–µ—Ç –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å. –ú–∞–∫—Å–∏–º—É–º.\n–©–æ–± –∑–º—ñ–Ω–∏—Ç–∏, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π /resetcrypto —ñ –¥–æ–¥–∞–π –Ω–æ–≤—ñ.")
            return

        coin_id, coin_name, coin_symbol_api = await search_token(text.lower())

        if not coin_id:
            await message.answer(f"‚ùå –ú–æ–Ω–µ—Ç—É '{text}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –°–ø—Ä–æ–±—É–π —ñ–Ω—à–∏–π –∑–∞–ø–∏—Ç –∞–±–æ —Ç—ñ–∫–µ—Ä.")
            return
        
        display_name_to_add = coin_symbol_api.upper() if coin_symbol_api else coin_name

        if coin_id in tokens_id_list:
            await message.answer(f"‚ÑπÔ∏è –ú–æ–Ω–µ—Ç–∞ {display_name_to_add} (ID: {hcode(coin_id)}) –≤–∂–µ –æ–±—Ä–∞–Ω–∞ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å.", parse_mode="HTML")
            return

        tokens_id_list.append(coin_id)
        tokens_display_list.append(display_name_to_add)
        
        user_config["tokens_id"] = tokens_id_list
        user_config["tokens_display"] = tokens_display_list
        all_users_data[user_id_str] = user_config
        save_data(all_users_data)

        await message.answer(f"‚úÖ –î–æ–¥–∞–Ω–æ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å: {display_name_to_add} (ID: {hcode(coin_id)})", parse_mode="HTML")
        
        if len(tokens_id_list) >= 5:
            await message.answer("–í–∏ –æ–±—Ä–∞–ª–∏ 5 –º–æ–Ω–µ—Ç –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å. –¢–µ–ø–µ—Ä –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ —á–∞—Å—Ç–æ—Ç—É: /setfrequency")
        elif len(tokens_id_list) > 0:
            await message.answer("–©–æ–± –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ —á–∞—Å—Ç–æ—Ç—É —Ä–µ–≥—É–ª—è—Ä–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /setfrequency")
        return 

# --- –ó–ê–ü–£–°–ö –ë–û–¢–ê ---
async def main(): 
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
    dp.message.register(start_cmd, Command(commands=["start"]))
    dp.message.register(my_config_cmd, Command(commands=["mycryptoconfig"]))
    dp.message.register(set_frequency_cmd, Command(commands=["setfrequency"]))
    
    # FSM –¥–ª—è price alert
    dp.message.register(cmd_set_price_alert_start, Command(commands=["setpricealert"]))
    dp.message.register(process_alert_coin_ticker, PriceAlertStates.waiting_coin_ticker)
    dp.message.register(process_alert_lower_target, PriceAlertStates.waiting_lower_target)
    dp.message.register(process_alert_upper_target, PriceAlertStates.waiting_upper_target)
    dp.message.register(cancel_alert_setup, Command(commands=["cancelalert"]), PriceAlertStates.any_state)

    dp.message.register(cmd_my_price_alert, Command(commands=["mypricealert"]))
    dp.message.register(cmd_remove_price_alert, Command(commands=["removepricealert"]))

    dp.message.register(reset_crypto_all_cmd, Command(commands=["resetcrypto"]))
    dp.message.register(stop_crypto_notifications_cmd, Command(commands=["stopcryptonotifications"]))
    
    dp.callback_query.register(add_token_callback, lambda c: c.data.startswith("add_"))
    dp.callback_query.register(process_frequency_callback, lambda c: c.data.startswith("setfreq_"))
    dp.callback_query.register(reset_crypto_all_callback, lambda c: c.data == "reset_all_crypto")
    # Callback –¥–ª—è `setfreq_off` (–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π) —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ `process_frequency_callback`

    # –¢–µ–∫—Å—Ç–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–º –∏–∑ dp.message.register
    dp.message.register(handle_text_input) 

    asyncio.create_task(price_update_scheduler())
    
    print(f"[{datetime.now(timezone.utc).isoformat()}] –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞—î—Ç—å—Å—è...")
    try:
        await dp.start_polling(bot, skip_updates=True) # skip_updates=True –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ
    finally:
        await bot.session.close() 
        print(f"[{datetime.now(timezone.utc).isoformat()}] –ë–æ—Ç –∑—É–ø–∏–Ω–µ–Ω–æ.")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"[{datetime.now(timezone.utc).isoformat()}] –ó—É–ø–∏–Ω–∫–∞ –±–æ—Ç–∞ –≤—Ä—É—á–Ω—É (Ctrl+C)")
    except Exception as e:
        print(f"[{datetime.now(timezone.utc).isoformat()}] –í–∏–Ω–∏–∫–ª–∞ –∫—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –∑–∞–ø—É—Å–∫—É: {e}")
